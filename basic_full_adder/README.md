# Basic 4 bit Full Adder
## About
The main aim of this project was to get familiar with Synopsys VCS and Verdi, and to learn how to use command-line workflows with Xilinx Vivado instead of relying on its GUI.
In this setup:

- VCS and Verdi are used for simulation and debugging.

- Vivado is used only for synthesis, implementation, and bitstream generation for the target FPGA device.

## About the Files and Structure
Iâ€™ve decided to follow a consistent folder structure across all projects. This ensures a clean and maintainable layout, simplifies tool integration, and improves readability later on.

- src: This folder consists of my src files meaning my design files
- tb: This folder consists of my testbench files
- sim: This folder contain my .fsdb and simv file generated by VCS and used by Verdi

## Workflow
I followed the following steps to work with the different tools

1. ### Write design and testbench files
First write the design and testbench files using a test editor, may it be gedit or vi editor.
2. ### Compile and generate the simulation executable
 Compile and generate executable using the following command
```
vcs -full64 src/4_bit_full_adder.v tb/4_bit_full_adder_tb.v -o sim/simv -lca -kdb -debug_access+all
```
	-full64 : Running on 64bit system
	-o : Specify output directory/file_name
	-lca : Limited Customer Availability, other case is general availability meaning multiple people can change/access the file but here we dont need to generalize it
	-kdb : Enable creation of kdb file (Knoweldge Data Base) during creation (Used for debugging and analysis)
	-debug-access+all : Meaning that we should be able to access all the signals in the modules and submodules even.
 
3. ### Run the simulation
Run the simv file using:
>  sim/simv
4. ### Open waveform in Verdi
The .fsdb file is generated which is opened in verdi using
```
verdi -ssf sim/*.fsdb -nologo
the .fsdb file here is generated from running ./simv (simv generated using VCS)
-ssf : Source Signal Format
```

## What I learned
This project helped me understand
- How to compile, simulated and debug Verilog Code using vcs and Verdi
- How to work with Vivado purely through the command line for synthesis and bitstream generation.
- How to use git for version control, and the importance of maintaining a consistent project directory structure for tool interoperability
